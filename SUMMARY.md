## 前端鉴权





## 安全优化

### 信息安全

信息安全的保护分成两个方面，端（具体到客户端和服务端）的安全和链路的安全，也就是传输过程的安全。

一般我们可以认为，端都是可信的。对于服务器端，你愿意使用这个公司提供的服务，一个隐含的条件就是相信这个提供服务的公司，所以服务器端可以认为是比较安全的。

而客户端，你愿意使用这台电脑，也表明你认为这台电脑是比较安全的。只有对于一些安全级别更高的业务，比如在线交易，才需要额外的再对客户端的安全性做一次校验。但是，要真正的保证客户端安全是很难的，需要使用像可信计算这样的技术。常见的能够很大程度保护客户端安全的设备，比如iOS设备、PSP之类的游戏机，也是能够遭到破解，所以这个问题至今没有比较完善的解决方案。
通常我们认为，自己肯定不会给自己的电脑装上木马，网吧的老板一般不会跟黑客一伙，也不会在网吧的电脑上装木马。所以保护的焦点，应该集中在通信的链路上，而不是端上，而且，在链路上进行窃听，比在大部分时候在端上进行攻击都来得有效和难以发现。

一个很简单的例子，如果我用笔记本在一个外租房比较密集的小区，建立一个无密码的WiFi热点，保证很多试图蹭网的人连接上来，然后如果我用WireShark（或者用WinPcap写一个过滤程序），监听WiFi收到转发的数据包，那一定能截获大批的用户名和口令，至少，如果他上知乎，用户名和口令我一定能得到。这个例子也说明了，各位千万不要贪图小便宜而去蹭别人的WiFi，这是一个对自己来说很危险的行为。



### HTTP安全方面缺点

* 通信使用明文会被窃听
* 不验证通信方的身份
* 无法证明报文完整性，可能被篡改（中间人攻击，MITM）

> [中间人攻击](https://baike.baidu.com/item/中间人攻击)（Man-in-the-MiddleAttack，简称“MITM攻击”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。 攻击方式：DNS欺骗（通过入侵DNS服务器、控制路由器等方法）、不可靠的代理服务器等



### HTTP明文传输

首先账户密码是完全暴露在请求体中

![image-20201008101606150](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008101606150.png)

![image-20201008104128392](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008104128392.png)

由于HTTP明文传输的特点，在本次登录中如果有人拦截到请求和响应就能够获取用户名和密码以及返回的JWT，这样用户的信息被暴露出来，很不安全。



### 对称加密

既然明文传输不安全，我们就使用对称加密的方式进行加密传输。对称加密即使用相同的密钥S加密和解密。

但是，密钥如果固定，客户端一旦泄露密钥，则能使用密钥解密。因此需要生成随机密钥。但怎么才能安全地告知对方密钥呢？

如果由服务器端直接告诉客户端该使用哪个密钥，密钥容易泄露，不能保证安全。



### 非对称加密+对称加密

如何对协商过程进行加密？

密码学领域中，有一种称为“非对称加密”的加密算法。

特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。

客户端用公钥对密钥S进行加密，发送给服务器。服务器收到后用私钥解密，得到密钥S。这样，客户端就能成功把密钥告知服务端了。因此，使用非对称加密算法进行对称加密算法协商过程，就能保证协商过程的安全了。

![image-20201008111012147](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008111012147.png)

> 为什么不能直接使用非对称加密，而是使用非对称加密算法进行对称加密算法协商过程？
>
> 因为公钥每个人都知道，服务器用私钥加密，中间人可以用公钥解密获取信息。即只能保证客户端向服务器发送信息安全，不能保证服务器向客户端发送信息安全。

但是问题又来了，客户端要怎么才能得到公钥？

如果由服务端直接向客户端发送公钥，公钥有可能被中间人调包。

![image-20201008182203505](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008182203505.png)

但让每个客户端的每个浏览器默认保存所有网站的公钥也是不现实的。



### 数字证书与数字签名

#### 数字证书

因此，我们利用第三方机构（CA，证书授权中心）颁发数字证书（加密后的公钥）。

CA使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。这样，浏览器只需要默认保存1个CA公钥（实际上可能还保存其他可信机构的公钥）就可以了。

![image-20201008183030339](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008183030339.png)

但是，CA不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的话，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用CA的公钥进行解密。



#### 数字签名

客户端可以通过验证证书的数字签名来鉴别证书的来源。

先用hash函数生成证书内容的摘要（digest），使用私钥，对这个摘要加密，生成“数字签名”（signature）。

![image-20201008184420330](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008184420330.png)

客户端拿到证书后，用CA公钥解密，根据证书上的方法自己生成一个摘要，如果生成的摘要与解密证书上的数字签名得到的摘要相同，那么说明这个证书是真实的，没有没篡改。然后，查看证书上的网站信息，如果与目前浏览器的网站一致，则说明证书的来源正确，从而正确鉴别对方的身份。

![image-20201008184855711](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201008184855711.png)





### https（超文本传输安全协议）

#### TLS 1.2

![image-20201009094011518](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201009094011518.png)

##### 1. Client Hello

首先，浏览器发送 client_random、TLS版本、加密套件列表。

client_random 是什么？用来最终 secret 的一个参数。

加密套件列表是什么？我举个例子，加密套件列表一般张这样:

```javascript
TLS_ECDHE_WITH_AES_128_GCM_SHA256
```

意思是`TLS`握手过程中，使用`ECDHE`算法生成`pre_random`(这个数后面会介绍)，128位的`AES`算法进行对称加密，在对称加密的过程中使用主流的`GCM`分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用`SHA256`算法。

![image-20201009085143586](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201009085143586.png)

##### 2. Server Hello

`server_random`是最后生成`secret`的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书.


![image-20201009090811757](https://gitee.com/huangguang1999/blog-image/raw/master/img/image-20201009090811757.png)

##### 3. Client 验证证书，生成secret

客户端验证服务端传来的`证书`和`签名`是否通过，如果验证通过，则传递`client_params`这个参数给服务器。

接着客户端通过`ECDHE`算法计算出`pre_random`，其中传入两个参数:**server_params**和**client_params**。现在你应该清楚这个两个参数的作用了吧，由于`ECDHE`基于`椭圆曲线离散对数`，这两个参数也称作`椭圆曲线的公钥`。

客户端现在拥有了`client_random`、`server_random`和`pre_random`，接下来将这三个数通过一个伪随机数函数来计算出最终的`secret`。

##### 4. Server生成secret

刚刚客户端不是传了`client_params`过来了吗？

现在服务端开始用`ECDHE`算法生成`pre_random`，接着用和客户端同样的伪随机数函数生成最后的`secret`。



#### RSA 和 ECDHE 握手过程的区别

ECDHE 握手，也就是主流的 TLS1.2 握手中，使用`ECDHE`实现`pre_random`的加密解密，没有用到 RSA。

使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前`抢跑`，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫`TLS False Start`。



#### 隐患

但是这样也并不是无懈可击的，如果中间人使用CA证书，如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器就会发出警告，但如果用户点击继续浏览此网站还是会被攻击成功。

![img](https://gitee.com/huangguang1999/blog-image/raw/master/img/16e0db5e18347142)

而如果中间人使用自己伪造的证书，同样也会发出警告。如果用户点击信任此证书还是会被攻击成功。所以黑客只要诱导用户安装自己伪造的证书即可，例如使用各种钓鱼的不可描述网站。

![img](https://gitee.com/huangguang1999/blog-image/raw/master/img/16e0db5e182e1047)